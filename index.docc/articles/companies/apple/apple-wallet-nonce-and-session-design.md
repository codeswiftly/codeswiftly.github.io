@PageImage(purpose: card, source: "companies-apple-apple-wallet-nonce-and-session-design-card.codex", alt: "Placeholder card")
@Image(source: "companies-apple-apple-wallet-nonce-and-session-design-hero.codex", alt: "Placeholder hero")
@PageImage(purpose: icon, source: "companies-apple-apple-wallet-nonce-and-session-design-icon.codex", alt: "Placeholder icon")
# Apple Wallet Nonce and Session Token Design

@Metadata {
  @TitleHeading("Review Apple Wallet Nonce and Session Token Design")
  @PageImage(purpose: icon, source: "apple-wallet-nonce-and-session-design-icon.codex", alt: "Apple Wallet Nonce and Session Token Design icon")
  @PageImage(purpose: card, source: "apple-wallet-nonce-and-session-design-card.codex", alt: "Apple Wallet Nonce and Session Token Design card")
}

@Image(source: "apple-wallet-nonce-and-session-design-hero.codex", alt: "Apple Wallet Nonce and Session Token Design hero")

## Overview

- Goal: explain how Apple Wallet and PassKit use a **nonce** and server-side session record to
  protect identity and payment flows from replay attacks.
- Scope: `PKIdentityRequest.nonce`, `AddPassToWalletButtonResponse.nonce`, and the backend data
  processing and concurrency patterns that keep everything in sync.

Use this article when you need to walk an interviewer through how you would design and implement
nonce-based replay protection for Wallet-style flows.

## What the Nonce Represents

From the raw PassKit docs:

- `PKIdentityRequest.nonce: Data?`
  - “An arbitrary number that the signed response payload includes.”
  - Maximum size: 64 bytes.
  - Opaque from the system’s point of view; your server must understand and reuse it.
- `AddPassToWalletButtonResponse.nonce: Data`
  - Similarly, a value your backend uses to tie a response to a request and session.

Design interpretation:

- The **nonce is a per-request, per-session token**:
  - Generated by your backend.
  - Embedded into the request (`PKIdentityRequest`, add-pass request, or similar).
  - Echoed back in the signed payload that Wallet returns.
- The backend **refuses to accept a payload** if:
  - The nonce does not match an active session.
  - The nonce was already used.
  - The nonce has expired by time or policy.

You can think of the nonce as a **one-time primary key** for a single Wallet interaction.

## End-to-end Flow with Nonce and Session

Here is a simplified sequence for Verify with Wallet; the same pattern applies to other
nonce-carrying APIs:

```text
Client App              Backend                 Wallet / System
---------              ----------              -----------------

1. startVerify
   ------------------>  createSession()
                        nonce = random(32B)
                        save(sessionID, nonce, status: .pending)
   <------------------  { sessionID, nonce, descriptor, merchantID }

2. build PKIdentityRequest
   request.descriptor        = descriptor
   request.merchantIdentifier = merchantID
   request.nonce             = nonce

3. requestDocument(request)
   ------------------------>  (Wallet UI, user consent)
                         <---  PKIdentityDocument(encryptedData, ...)

4. sendToBackend
   encryptedData, nonce, sessionID
   ------------------>  loadSession(sessionID)
                        assert(storedNonce == nonce)
                        decrypt(encryptedData, merchantKeys)
                        validate signatures, timestamps, attributes
                        mark session status: .used
   <------------------  decision (for example, ageVerified: true)
```

Interview talking point: the **nonce and session record form a small state machine** on the
backend that prevents replay and ties a Wallet response to a single request.

## Generating a Strong Nonce on the Backend

On the server, you want:

- Cryptographically strong randomness.
- Fixed-size, bounded values (≤ 64 bytes) to match PassKit’s constraints.
- A stable place to persist the nonce with its session.

```swift
import Foundation
import Security

enum NonceError: Error {
  case generationFailed(OSStatus)
}

func generateNonce(length: Int = 32) throws -> Data {
  precondition(length > 0 && length <= 64, "PassKit allows up to 64 bytes")

  var buffer = [UInt8](repeating: 0, count: length)
  let status = SecRandomCopyBytes(kSecRandomDefault, length, &buffer)
  guard status == errSecSuccess else {
    throw NonceError.generationFailed(status)
  }
  return Data(buffer)
}
```

You then bind this nonce to an identity-verification session:

```swift
struct IdentitySession: Sendable {
  enum Status: Sendable {
    case pending
    case completed
    case expired
  }

  let id: UUID
  let nonce: Data
  let createdAt: Date
  var status: Status
}
```

In an interview, call out that you **never reuse a nonce** and always store it with timestamps and a
status flag.

## Concurrency Pattern: Actor-based Session Store

To keep the session state consistent under concurrency, wrap it in an `actor` so that reads and
writes are serialized:

```swift
actor IdentitySessionStore {
  private var sessions: [UUID: IdentitySession] = [:]

  func createSession() async throws -> IdentitySession {
    let nonce = try generateNonce()
    let session = IdentitySession(
      id: UUID(),
      nonce: nonce,
      createdAt: Date(),
      status: .pending
    )
    sessions[session.id] = session
    return session
  }

  func markCompleted(id: UUID) {
    guard var session = sessions[id] else { return }
    session.status = .completed
    sessions[id] = session
  }

  func load(id: UUID) -> IdentitySession? {
    sessions[id]
  }
}
```

This mirrors the style of other data-processing pipelines in `mono`: **keep mutable state inside an
actor or dedicated type** so that concurrent requests cannot race to reuse or overwrite a nonce.

## Client-side: Building `PKIdentityRequest` with a Nonce

On the client, you treat the nonce as opaque data that comes from your backend:

```swift
import PassKit

struct IdentitySessionSummary {
  let id: UUID
  let nonce: Data
}

func makeIdentityRequest(
  summary: IdentitySessionSummary,
  descriptor: PKIdentityDocumentDescriptor,
  merchantIdentifier: String
) -> PKIdentityRequest {
  let request = PKIdentityRequest()
  request.descriptor = descriptor
  request.merchantIdentifier = merchantIdentifier
  request.nonce = summary.nonce
  return request
}
```

You then pass this request into a `PKIdentityAuthorizationController`:

```swift
func runIdentityVerification(
  summary: IdentitySessionSummary,
  descriptor: PKIdentityDocumentDescriptor,
  merchantIdentifier: String
) async throws -> PKIdentityDocument {
  let controller = PKIdentityAuthorizationController()
  let request = makeIdentityRequest(
    summary: summary,
    descriptor: descriptor,
    merchantIdentifier: merchantIdentifier
  )
  return try await controller.requestDocument(request)
}
```

Design principle: **the client never manufactures the nonce**. It just forwards the server-provided
value into the PassKit APIs and later back to the server alongside `encryptedData`.

## Backend Verification with Nonce

When the client sends the result back, your verification handler might look conceptually like this:

```swift
struct VerifyWalletIdentityPayload: Decodable {
  let sessionID: UUID
  let encryptedData: Data
  let nonce: Data
}

func verifyWalletIdentity(
  _ payload: VerifyWalletIdentityPayload,
  sessionStore: IdentitySessionStore
) async throws -> IdentityDecision {
  guard let session = await sessionStore.load(id: payload.sessionID) else {
    throw IdentityError.unknownSession
  }

  guard session.status == .pending else {
    throw IdentityError.sessionAlreadyUsed
  }

  guard session.nonce == payload.nonce else {
    throw IdentityError.nonceMismatch
  }

  // 1. Decrypt payload.encryptedData using keys bound to your merchant identifier.
  // 2. Validate issuer and device signatures.
  // 3. Validate timestamps and requested attributes.
  // 4. Map fields into your internal model.

  await sessionStore.markCompleted(id: session.id)

  return IdentityDecision(
    isVerified: true,
    documentCountry: "US",
    decisionReason: "ageVerifiedOver21"
  )
}
```

This is where you connect the **nonce-based session state machine** to the **ISO 18013-5 data
processing pipeline** from `<doc:apple-wallet-iso18013-data-processing>`.

## Talking Points for Interviews

- **Purpose of the nonce:**
  - Protects against replay of a previously captured Wallet response.
  - Binds a specific `PKIdentityRequest` (or add-pass request) to a backend session.
- **Where it lives:**
  - Generated and stored on the backend.
  - Forwarded to the client only to be echoed into PassKit APIs and back.
  - Included inside the signed payload so the backend can validate it.
- **Concurrency and data processing:**
  - Use actors or other synchronization primitives to manage nonce lifecycle so that concurrent
    calls cannot accidentally reuse or double-spend a nonce.
  - Treat the backend as the root of trust; the client just carries `encryptedData` and `nonce`
    between Wallet and your servers.

Tie this back to your broader stories about **CredentialStore**, **CommonProcess** data pipelines,
and other parts of `mono`: you are consistently using **typed data, small state machines, and
well-defined concurrency boundaries** to keep sensitive flows safe and understandable.
